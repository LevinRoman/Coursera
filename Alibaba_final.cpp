/*1)Кратчайший путь для отрезка с монетами кончается либо на левой монете, либо на правой монете.

2)Считаем для каждого отрезка какой-то определенной длины две величины:
    1.длину кратчайшего пути, который покрывает его и оканчивается на левой монете. (Покрытие-справа-налево)
    Покрывает - проходит минимальным путем, собирая все монеты.
    2.длину кратчайшего пути, который покрывает его и оканчивается на правой монете. (Покрытие-слева-направо)

3)База индукции: отрезки длины 0, для каждого из них искомые величины: (0, 0)
4)Пусть теперь у нас отрезок [1,n]:
    1. Ищем кратчайший путь его покрыть и оказаться в монете n(ищем покрытие-слева-направо[1,n]) :
          В монете 1 мы побываем, очевидно, только 1 раз.
          Были ли мы теперь в монете n хотя бы раз, прежде чем попасть в первую?
              ДА(ПЕРВАЯ ВОЗМ):  Тогда мы сначала ходили по отрезку [2,n], были во всех его монетах, в итоге оказались во 2-й, потом пошли к первой, а затем нужно вернуться к n-й.
                   Такой путь (далее мы назовем его optend_l_r)будет иметь длину: покрытие-справа-налево[2,n] + расстояние[1,2] + расстояние[1,n]
                   Мы сможем его осуществить, если успеем собрать 1-ю монету, т.е. покрытие-справа-налево[2,n] + расстояние[1,2] <= срок-годности[1]
              НЕТ(ВТОРАЯ ВОЗМ): Тогда мы сначала покрыли слева-направо[1,n-1], а потом пришли в [n].
                   Длина пути optbeg_l_r: покрытие-слева-направо[1,n-1] + расстояние[n-1,n]
                   Сможем осуществить, если успеем собрать [n]:  покрытие-слева-направо[1,n-1]+ расстояние[n-1,n] <= срок-годности[n]
    2. Ищем покрытие-справа-налево[1,n] :
          Снова выбираем между двумя возможностями:
              ПЕРВАЯ: Сначала покрыть [2,n] справа налево, потом дойти до [1].
                      Длина пути optend_r_l: покрытие-справа-налево[2,n] + расстояние[1,2]
                      Осуществимость: если успеем собрать [1], т.е. если покрытие-справа-налево[2,n] + расстояние[1,2] <= срок-годности[1]
              Вторая: Сначала покрыть [1,n-1] слева направо, потом дойти до [n], потом дойти до [1].
                      Длина пути optbeg_r_l: покрытие-слева-направо[1,n-1] + расстояние[n-1,n] + расстояние[1,n]
                      Осуществимость: если успеем собрать [n]: покрытие-слева-направо[1,n-1]+ расстояние[n-1,n] <= срок-годности[n]
5)Для отрезка [1,n] выбираем из покрытий справа налево и слева направо самое быстрое. Это и будет ответом к задаче. Если оба покрытия оказались неосуществимы,
то no solution.
6) ПОБЕДА! Отрезков длины 1 n штук. Всего разных длин n штук. Пересчитать длины покрытий надо будет порядка n раз. Пересчитывается за константу через предыдущие.
Сложность: O(N^2)*/
#include <vector>
#include <iostream>
#include <algorithm>

bool sort_func(std::vector <int> one, std::vector <int> two) //Задаем отношение, по которому будем
{                                                            //сортировать входной вектор пар {(координата монеты, срок годности)}.
     return (one[0] < two[0]);                               //Сортить будем по первой координате, чтобы монетки положить на дороге правильно.
}

int main()
{
     std::ios_base::sync_with_stdio(false); //волшебные строчки с самого первого семинара, которые ускоряют прогу
     std::cin.tie(nullptr);// волшебные строчки
     int num;
     std::cin >> num; //считываем все. Монеты и сроки годности считываем в вектор из двумерных векторов
     std::vector <std::vector<int>> coins;
     std::vector <int> coin(2);
     for (int i = 0; i < num; ++i)
     {
          for (int j = 0; j < 2; ++j)
          {
               std::cin >> coin[j];
          }
          coins.push_back(coin);
     } //закончили считывать
     std::sort(coins.begin(), coins.end(), sort_func); // сортим вектор монет, раскладываем их по дороге в порядке
     /*Нам надо посчитать для каждого отрезка [i,j] две величины: покрытие-слева-направо[i,j], покрытие-справа-налево[i,j]. Будем хранить
     все это в матрице l_r_cover, где в верхнем треугольнике лежат покрытия-слева-направо, в нижнем треугольнике - покрытия-справа-налево.
     Т.е. для какого-то отрезка [i,j]: покрытие-слева-направо[i,j]=l_r_cover[i][j], покрытие-справа-налево[i,j]=l_r_cover[j][i].
     На диагонали этой матрицы будут [i][i] - отрезки длины ноль, для которых длины обоих оптимальных путей нули. Т.е. гл.диагональ матрицы нулевая.*/
     std::vector <int> initial_covering(num, 0); //инициализируем матрицу нулями
     std::vector <std::vector <int>> l_r_cover(num, initial_covering); //инициализируем матрицу нулями
     int first(0), last, len(0), optbeg_l_r, optend_l_r, optbeg_r_l, optend_r_l; // переменные для дальнейшего подсчета матрицы покрытий
     //first - начало отрезка, last - конец отрезка, len - текущая длина отрезка,
     //optend_l_r(т.е. option_end_left_right) - длина пути из первой возможности для покр-слева-направо, когда сначала покрываем конец отрезка,
     //потом - начало. posend_l_r (possibility_end_l_r) - осуществимость этого пути. Аналогично для покр-справа-налево: optend_r_l, posend_r_l.
     //optbeg_l_r(т.е. optinon_beggining_l_r), optbeg_l_r - длина пути из второй возможности, когда сначала покрываем начало.
     //posbeg_l_r и posbeg_r_l - осуществимости этих путей.
     bool posbeg_l_r, posend_l_r, posbeg_r_l, posend_r_l;
     for (int ind = 1; ind < num; ++ind) // Начинаем развлекаться. Заполняем матрицу подиагонально, т.е. ведем индукцию по длине отрезков.
     {                                   // Всего у нас num-1 диагональка или num-1 различная длина, т.к. главную диагональ мы уже заполнили.
          ++len;
          for (int jind = 0; jind < num - len; ++jind)// Этот цикл заполняет две конкретные диагонали, соответствующие одинаковым длинам.
          {                                           // Т.е. над и под главной диагональю. Одновременно вычисляем покрытия слева-направо и
                                                      // справа-налево отрезков длины len, т.к. и те, и др нам нужны на следующем шаге индукции.
               last = first + len; //координата конца отрезка. Координату начала отрезка увеличим в конце цикла.

               optend_l_r = l_r_cover[last][first + 1] + //Вычисляем длину пути l_r для первой возможности
               (coins[first + 1][0] - coins[first][0]) + //
               (coins[last][0] - coins[first][0]);       //тут контест ругался на длинные строчки, поэтому криво

               posend_l_r = (l_r_cover[last][first + 1] + //Вычисляем осуществимость
                             (coins[first + 1][0] - coins[first][0])
                             <= coins[first][1]);

               if (l_r_cover[last][first + 1] == -1) // Значение -1 в матрице соответствует неосуществимости какого-то покрытия.
               {                                     // Если никакое покрытие отрезка меньшей длины неосуществимо, то неосуществимо и следующее,
                    posend_l_r = false;              //которое его использует. Это нужно, чтобы суметь No solution написать
               }

               optbeg_l_r = l_r_cover[first][last - 1] + //Длина пути l_r для второй возможности
               (coins[last][0] - coins[last - 1][0]);    //

               posbeg_l_r = (l_r_cover[first][last - 1] + //Его осуществимость
                             (coins[last][0] - coins[last - 1][0])
                             <= coins[last][1]);

               if (l_r_cover[first][last - 1] == -1) //Его нельзя также осуществить, если предыдущее покрытие неосуществимо.
               {
                    posbeg_l_r = false;
               }

               if (posbeg_l_r && posend_l_r) //Выбираем далее самое быстрое и осуществимое.
               {
                    l_r_cover[first][last] = std::min(optend_l_r, optbeg_l_r);
               }
               else
               {
                    if (posbeg_l_r)
                    {
                         l_r_cover[first][last] = optbeg_l_r;
                    }
                    if (posend_l_r)
                    {
                         l_r_cover[first][last] = optend_l_r;
                    }
                    if (!posbeg_l_r && !posend_l_r)
                    {
                         l_r_cover[first][last] = -1; // Если ничего не смогли выбрать, то покрытие l_r неосуществимо, в матрицу пишем -1.
                    }
               }

               optend_r_l = l_r_cover[last][first + 1] +
               (coins[first + 1][0] - coins[first][0]);//Аналогично вычисляем пути и осуществимости для r_l покрытия.
               posend_r_l = posend_l_r;

               optbeg_r_l = l_r_cover[first][last - 1] +
               (coins[last][0] - coins[last - 1][0]) +
               (coins[last][0] - coins[first][0]);

               posbeg_r_l = posbeg_l_r;

               if (posbeg_r_l && posend_r_l)
               {
                    l_r_cover[last][first] = std::min(optend_r_l, optbeg_r_l);
               }
               else
               {
                    if (posbeg_r_l)
                    {
                         l_r_cover[last][first] = optbeg_r_l;
                    }
                    if (posend_r_l)
                    {
                         l_r_cover[last][first] = optend_r_l;
                    }
                    if (!posbeg_r_l && !posend_r_l)
                    {
                         l_r_cover[last][first] = -1;
                    }
               }
               ++first;//вычислили для данного отрезка [first,last] длины len, пошли к следующему отрезку длины len.
          }
          first = 0;// Как только меняется длина отрезка, нужно обнулить координату начала.
     }
     int optimal_way;
//Ответом на задачку будет min(правый верхний элемент матрицы, левый нижний элемент матрицы), если оба осуществимы. Или осуществимый. Или Nosolution.
     if (l_r_cover[0][num - 1] != -1 && l_r_cover[num - 1][0] != -1)
     {
          optimal_way = std::min(l_r_cover[0][num - 1], l_r_cover[num - 1][0]);
     }
     else
     {
          if (l_r_cover[0][num - 1] != -1)
          {
               optimal_way = l_r_cover[0][num - 1];
          }
          if (l_r_cover[num - 1][0] != -1)
          {
               optimal_way = l_r_cover[num - 1][0];
          }
          if (l_r_cover[0][num - 1] == -1 && l_r_cover[num - 1][0] == -1)
          {
               optimal_way = -1;
          }
     }

     if (optimal_way > -1)
     {
          std::cout << optimal_way;
     }
     else
     {
          std::cout << "No solution";
     }
}
